<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>GLB: супер-минимал</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    #c { width:100%; height:100%; display:block; }
    #log { position:fixed; left:8px; bottom:8px; color:#0f0; font:12px/1.4 monospace; white-space:pre-line; pointer-events:none; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="log"></div>

  <!-- ОДНА версия r158 и немодульные примеры -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/examples/js/loaders/DRACOLoader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/examples/js/loaders/KTX2Loader.js"></script>
  <script src="https://unpkg.com/meshoptimizer/meshopt_decoder.js"></script>

  <script>
    // ===== переключатель: сначала проверь публичной моделью =====
    const USE_TEST = true; // <- ПОСЛЕ проверки поставь false
    const URL = USE_TEST
      ? 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb'
      : 'models/car.glb';

    const log = document.getElementById('log');
    const L = (...a) => { console.log(...a); log.textContent = [log.textContent, a.map(x=>String(x)).join(' ')].filter(Boolean).join('\n').slice(-1200); };

    // ===== сцена максимально простая =====
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(0, 1.2, 3);
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 1));

    // ===== лоадер с декодерами (на случай Draco/KTX2/Meshopt) =====
    const loader = new THREE.GLTFLoader();

    const draco = new THREE.DRACOLoader();
    draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    loader.setDRACOLoader(draco);

    const ktx2 = new THREE.KTX2Loader();
    // Путь к транскодерам BasisU (совместим и с немодульной версией)
    ktx2.setTranscoderPath('https://unpkg.com/three@0.158.0/examples/jsm/libs/basis/');
    ktx2.detectSupport(renderer);
    loader.setKTX2Loader(ktx2);

    if (typeof MeshoptDecoder !== 'undefined') {
      loader.setMeshoptDecoder(MeshoptDecoder);
    }

    // ===== загрузка =====
    L('Загружаю:', URL);
    loader.load(URL, (gltf) => {
      L('OK:', 'модель загружена');
      const o = gltf.scene || gltf.scenes[0];
      // автоцентр и скейл по желанию
      o.traverse(n => { if (n.isMesh && n.material && n.material.map) n.material.map.colorSpace = THREE.SRGBColorSpace; });
      scene.add(o);
    }, (e) => {
      if (e.total) L('progress', Math.round(e.loaded/e.total*100)+'%');
      else L('progress', e.loaded || 0);
    }, (err) => {
      L('ERR загрузки:', err?.message || err);
      // простой куб-фолбэк, чтобы было видно, что рендер жив
      const cube = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshNormalMaterial());
      scene.add(cube);
    });

    // ===== render loop =====
    function tick(){
      requestAnimationFrame(tick);
      renderer.render(scene, camera);
    }
    tick();

    addEventListener('resize', () => {
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    // ловим глобальные ошибки — сразу видно корень
    addEventListener('error', (e) => L('window error:', e.message || e.error));
    addEventListener('unhandledrejection', (e) => L('promise rejection:', e.reason?.message || e.reason));
  </script>
</body>
</html>
